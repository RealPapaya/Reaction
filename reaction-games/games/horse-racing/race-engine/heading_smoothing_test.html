<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heading å¹³æ»‘åº¦å°æ¯”æ¸¬è©¦</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #0f0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #0f0;
        }

        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .panel {
            background: #000;
            border: 2px solid #0f0;
            padding: 15px;
        }

        .panel h2 {
            margin-top: 0;
            color: #0f0;
            text-align: center;
        }

        .panel.bad h2 {
            color: #f00;
        }

        .panel.good h2 {
            color: #0f0;
        }

        canvas {
            display: block;
            width: 100%;
            background: #111;
            border: 1px solid #333;
            margin: 10px 0;
        }

        .stats {
            background: #222;
            padding: 10px;
            margin: 10px 0;
            font-size: 12px;
        }

        .stats .jump {
            color: #f00;
            font-weight: bold;
        }

        .stats .smooth {
            color: #0f0;
            font-weight: bold;
        }

        button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            margin: 5px;
        }

        button:hover {
            background: #0f0;
            opacity: 0.8;
        }

        .explanation {
            background: #222;
            border-left: 4px solid #ff0;
            padding: 15px;
            margin: 20px 0;
        }

        .explanation h3 {
            margin-top: 0;
            color: #ff0;
        }

        code {
            background: #333;
            padding: 2px 6px;
            color: #0ff;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ğŸ” Heading å¹³æ»‘åº¦è¨ºæ–·å·¥å…·</h1>

        <div style="text-align: center; margin: 20px 0;">
            <button onclick="runTest()">â–¶ åŸ·è¡Œæ¸¬è©¦</button>
            <button onclick="location.reload()">ğŸ”„ é‡æ–°è¼‰å…¥</button>
        </div>

        <div class="explanation">
            <h3>âš ï¸ å•é¡Œèªªæ˜</h3>
            <p>
                ä½ çš„è³½é¦¬æ¨¡æ“¬å™¨åœ¨è½‰å½æ™‚å‡ºç¾<strong>å¡é “</strong>ï¼ŒåŸå› æ˜¯ <code>frenetToWorld()</code> ä¸­çš„ heading æ’å€¼é‚è¼¯æœ‰<strong>çªè®Šé»</strong>ã€‚
            </p>
            <p>
                <strong>åŸå§‹é‚è¼¯ï¼š</strong><br>
                - ç•¶ <code>segmentProgress < 0.15</code> æ™‚ï¼šä½¿ç”¨æ’å€¼<br>
                - ç•¶ <code>0.15 â‰¤ segmentProgress â‰¤ 0.85</code> æ™‚ï¼šä½¿ç”¨<strong>å›ºå®šå€¼</strong><br>
                - ç•¶ <code>segmentProgress > 0.85</code> æ™‚ï¼šä½¿ç”¨æ’å€¼
            </p>
            <p style="color: #f00;">
                <strong>å•é¡Œï¼š</strong>ç•¶ progress å¾ 0.14 è®Šæˆ 0.16 æ™‚ï¼Œheading æœƒå¾ã€Œå¹³æ»‘æ’å€¼ã€<strong>çªç„¶åˆ‡æ›</strong>åˆ°ã€Œå›ºå®šå€¼ã€ï¼Œ
                é€ æˆé¦¬åŒ¹æ–¹å‘è·³å‹•ï¼Œç”¢ç”Ÿå¡é “æ„Ÿï¼
            </p>
            <p style="color: #0f0;">
                <strong>è§£æ±ºæ–¹æ¡ˆï¼š</strong>åœ¨<strong>æ•´å€‹ç·šæ®µ</strong>ä¸Šéƒ½é€²è¡Œå¹³æ»‘æ’å€¼ï¼Œç§»é™¤ 0.15/0.85 çš„ç¡¬é‚Šç•Œã€‚
            </p>
        </div>

        <div class="comparison">
            <div class="panel bad">
                <h2>âŒ åŸå§‹ç‰ˆæœ¬ï¼ˆæœ‰çªè®Šï¼‰</h2>
                <canvas id="canvasBad" width="600" height="300"></canvas>
                <div id="statsBad" class="stats">ç­‰å¾…æ¸¬è©¦...</div>
            </div>

            <div class="panel good">
                <h2>âœ… ä¿®æ­£ç‰ˆæœ¬ï¼ˆå¹³æ»‘ï¼‰</h2>
                <canvas id="canvasGood" width="600" height="300"></canvas>
                <div id="statsGood" class="stats">ç­‰å¾…æ¸¬è©¦...</div>
            </div>
        </div>

        <div class="explanation">
            <h3>ğŸ“Š å¦‚ä½•åˆ¤è®€çµæœ</h3>
            <ul>
                <li><span class="jump">ç´…é»</span>ï¼šheading è·³è®Šé»ï¼ˆå¤§æ–¼ 0.5Â°ï¼‰</li>
                <li><span class="smooth">ç¶ ç·š</span>ï¼šheading è®ŠåŒ–æ›²ç·š</li>
                <li>è·³è®Šæ•¸é‡ï¼šè¶Šå°‘è¶Šå¥½ï¼ˆç†æƒ³ç‚º 0ï¼‰</li>
                <li>æœ€å¤§è·³è®Šï¼šè¶Šå°è¶Šå¥½ï¼ˆç†æƒ³ < 0.5Â°ï¼‰</li>
            </ul>
        </div>

        <div id="console"
            style="background: #000; border: 2px solid #0f0; padding: 15px; margin-top: 20px; font-size: 12px; max-height: 300px; overflow-y: auto;">
        </div>
    </div>

    <script>
        const consoleDiv = document.getElementById('console');

        function log(msg, color = '#0f0') {
            const line = document.createElement('div');
            line.style.color = color;
            line.textContent = msg;
            consoleDiv.appendChild(line);
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        // å»ºç«‹æ¸¬è©¦è³½é“
        function createTestTrack() {
            const points = [];
            const straightLength = 280;
            const cornerRadius = 120;
            const centerX = 0;
            const centerY = 0;
            const numPointsPerSegment = 25;

            // ä¸Šç›´ç·š
            for (let i = 0; i < numPointsPerSegment; i++) {
                const t = i / numPointsPerSegment;
                points.push({
                    x: centerX - straightLength / 2 + t * straightLength,
                    y: centerY - cornerRadius
                });
            }

            // å³å½é“
            for (let i = 0; i < numPointsPerSegment; i++) {
                const t = i / numPointsPerSegment;
                const angle = -Math.PI / 2 + t * Math.PI;
                points.push({
                    x: centerX + straightLength / 2 + Math.cos(angle) * cornerRadius,
                    y: centerY + Math.sin(angle) * cornerRadius
                });
            }

            // ä¸‹ç›´ç·š
            for (let i = 0; i < numPointsPerSegment; i++) {
                const t = i / numPointsPerSegment;
                points.push({
                    x: centerX + straightLength / 2 - t * straightLength,
                    y: centerY + cornerRadius
                });
            }

            // å·¦å½é“
            for (let i = 0; i < numPointsPerSegment; i++) {
                const t = i / numPointsPerSegment;
                const angle = Math.PI / 2 + t * Math.PI;
                points.push({
                    x: centerX - straightLength / 2 + Math.cos(angle) * cornerRadius,
                    y: centerY + Math.sin(angle) * cornerRadius
                });
            }

            return points;
        }

        // åŸå§‹ç‰ˆæœ¬çš„ frenetToWorldï¼ˆæœ‰çªè®Šï¼‰
        function frenetToWorldOld(frenet, s, d) {
            s = Math.max(0, Math.min(s, frenet.pathLength));
            const segment = frenet.findSegment(s);

            if (!segment) {
                return { heading: 0 };
            }

            const segmentProgress = (s - segment.startDistance) / segment.length;
            const segmentIndex = segment.index;

            let smoothHeading = segment.heading;

            // **å•é¡Œä»£ç¢¼ï¼š0.15/0.85 ç¡¬é‚Šç•Œ**
            if (segmentProgress < 0.15 && segmentIndex > 0) {
                const prevSegment = frenet.segments[segmentIndex - 1];
                const t = segmentProgress / 0.15;
                smoothHeading = interpolateAngle(prevSegment.heading, segment.heading, t);
            } else if (segmentProgress > 0.85 && segmentIndex < frenet.segments.length - 1) {
                const nextSegment = frenet.segments[segmentIndex + 1];
                const t = (segmentProgress - 0.85) / 0.15;
                smoothHeading = interpolateAngle(segment.heading, nextSegment.heading, t);
            }
            // **ä¸­é–“å€åŸŸä½¿ç”¨å›ºå®šå€¼ segment.heading**

            return { heading: smoothHeading };
        }

        // ä¿®æ­£ç‰ˆæœ¬çš„ frenetToWorldï¼ˆå…¨ç·šæ®µå¹³æ»‘ï¼‰
        function frenetToWorldNew(frenet, s, d) {
            s = Math.max(0, Math.min(s, frenet.pathLength));
            const segment = frenet.findSegment(s);

            if (!segment) {
                return { heading: 0 };
            }

            const segmentProgress = (s - segment.startDistance) / segment.length;
            const segmentIndex = segment.index;

            let smoothHeading = segment.heading;

            const hasPrev = segmentIndex > 0;
            const hasNext = segmentIndex < frenet.segments.length - 1;

            if (hasPrev && hasNext) {
                const prevSegment = frenet.segments[segmentIndex - 1];
                const nextSegment = frenet.segments[segmentIndex + 1];

                // **ä¿®æ­£ï¼šå…¨ç·šæ®µå¹³æ»‘æ’å€¼**
                const distToStart = segmentProgress;
                const distToEnd = 1.0 - segmentProgress;
                const blendWidth = 0.5;

                let prevWeight = distToStart < blendWidth ? (blendWidth - distToStart) / blendWidth : 0;
                let nextWeight = distToEnd < blendWidth ? (blendWidth - distToEnd) / blendWidth : 0;

                let currentWeight = Math.max(0, 1 - prevWeight - nextWeight);
                const totalWeight = prevWeight + currentWeight + nextWeight;

                if (totalWeight > 0) {
                    prevWeight /= totalWeight;
                    currentWeight /= totalWeight;
                    nextWeight /= totalWeight;
                }

                const h0 = prevSegment.heading;
                const h1 = segment.heading;
                const h2 = nextSegment.heading;

                const diff1 = normalizeAngle(h1 - h0);
                const diff2 = normalizeAngle(h2 - h1);

                const normalizedH0 = h0;
                const normalizedH1 = h0 + diff1;
                const normalizedH2 = normalizedH1 + diff2;

                smoothHeading = normalizedH0 * prevWeight +
                    normalizedH1 * currentWeight +
                    normalizedH2 * nextWeight;

                smoothHeading = normalizeAngle(smoothHeading);
            }

            return { heading: smoothHeading };
        }

        function interpolateAngle(angle1, angle2, t) {
            let diff = angle2 - angle1;
            if (diff > Math.PI) diff -= 2 * Math.PI;
            else if (diff < -Math.PI) diff += 2 * Math.PI;
            let result = angle1 + diff * t;
            while (result > Math.PI) result -= 2 * Math.PI;
            while (result < -Math.PI) result += 2 * Math.PI;
            return result;
        }

        function normalizeAngle(angle) {
            while (angle > Math.PI) angle -= 2 * Math.PI;
            while (angle < -Math.PI) angle += 2 * Math.PI;
            return angle;
        }

        // ç°¡åŒ–çš„ Frenet ç³»çµ±ï¼ˆåƒ…ç”¨æ–¼æ¸¬è©¦ï¼‰
        function createFrenet(trackPath) {
            const segments = [];
            let accumulatedDistance = 0;

            for (let i = 1; i < trackPath.length; i++) {
                const p1 = trackPath[i - 1];
                const p2 = trackPath[i];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const heading = Math.atan2(dy, dx);

                segments.push({
                    startPoint: p1,
                    endPoint: p2,
                    startDistance: accumulatedDistance,
                    endDistance: accumulatedDistance + length,
                    length: length,
                    heading: heading,
                    index: i - 1
                });

                accumulatedDistance += length;
            }

            return {
                segments: segments,
                pathLength: accumulatedDistance,
                findSegment: function (s) {
                    for (const seg of this.segments) {
                        if (s >= seg.startDistance && s <= seg.endDistance) {
                            return seg;
                        }
                    }
                    return this.segments[this.segments.length - 1];
                }
            };
        }

        // æ¸¬è©¦å‡½æ•¸ - åˆ†æå¹³æ»‘åº¦å’Œçªè®Š
        function testHeadingSmoothing(frenet, testFunc, numSamples = 1000) {
            const headings = [];
            const jumps = [];
            const smallChanges = [];

            for (let i = 0; i < numSamples; i++) {
                const s = (i / numSamples) * frenet.pathLength;
                const result = testFunc(frenet, s, 0);
                headings.push(result.heading);

                if (i > 0) {
                    let diff = normalizeAngle(result.heading - headings[i - 1]);
                    const diffDeg = Math.abs(diff * 180 / Math.PI);

                    // åˆ†é¡ï¼šçœŸæ­£çš„çªè®Š vs å¹³æ»‘è®ŠåŒ–
                    if (diffDeg > 2.0) {
                        // å¤§æ–¼ 2Â° æ‰ç®—çœŸæ­£çš„ã€Œè¦–è¦ºå¯è¦‹è·³è®Šã€
                        jumps.push({
                            index: i,
                            s: s,
                            diffDeg: diffDeg
                        });
                    } else if (diffDeg > 0.5) {
                        // 0.5-2Â° ä¹‹é–“ç®—å°è®ŠåŒ–
                        smallChanges.push({
                            index: i,
                            s: s,
                            diffDeg: diffDeg
                        });
                    }
                }
            }

            // è¨ˆç®—è®ŠåŒ–ç‡æ¨™æº–å·®ï¼ˆè¡¡é‡å¹³æ»‘åº¦ï¼‰
            const changes = [];
            for (let i = 1; i < headings.length; i++) {
                let diff = normalizeAngle(headings[i] - headings[i - 1]);
                changes.push(Math.abs(diff));
            }

            const avgChange = changes.reduce((a, b) => a + b, 0) / changes.length;
            const variance = changes.reduce((sum, val) => sum + Math.pow(val - avgChange, 2), 0) / changes.length;
            const stdDev = Math.sqrt(variance);

            return {
                headings,
                jumps,
                smallChanges,
                smoothness: stdDev * 1000  // å¹³æ»‘åº¦æŒ‡æ¨™ï¼ˆè¶Šå°è¶Šå¥½ï¼‰
            };
        }

        // ç¹ªè£½çµæœ
        function drawResults(canvas, headings, jumps, smallChanges) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, width, height);

            // ç¹ªè£½ heading æ›²ç·š
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 2;
            ctx.beginPath();

            headings.forEach((h, i) => {
                const x = (i / headings.length) * width;
                const y = height / 2 - h * (height / (2 * Math.PI)) * 0.8;

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();

            // ç¹ªè£½å°è®ŠåŒ–é»ï¼ˆé»ƒè‰²ï¼‰
            ctx.fillStyle = '#ff0';
            smallChanges.forEach(change => {
                const x = (change.index / headings.length) * width;
                const h = headings[change.index];
                const y = height / 2 - h * (height / (2 * Math.PI)) * 0.8;

                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // ç¹ªè£½çœŸæ­£çš„è·³è®Šé»ï¼ˆç´…è‰²ï¼‰
            ctx.fillStyle = '#f00';
            jumps.forEach(jump => {
                const x = (jump.index / headings.length) * width;
                const h = headings[jump.index];
                const y = height / 2 - h * (height / (2 * Math.PI)) * 0.8;

                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
            });

            // ç¹ªè£½ä¸­ç·š
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, height / 2);
            ctx.lineTo(width, height / 2);
            ctx.stroke();
        }

        // åŸ·è¡Œæ¸¬è©¦
        function runTest() {
            log('=== é–‹å§‹æ¸¬è©¦ ===', '#ff0');

            const trackPath = createTestTrack();
            const frenet = createFrenet(trackPath);

            log(`è³½é“é•·åº¦: ${frenet.pathLength.toFixed(2)}m`);
            log(`ç·šæ®µæ•¸é‡: ${frenet.segments.length}`);
            log('');

            // æ¸¬è©¦åŸå§‹ç‰ˆæœ¬
            log('æ¸¬è©¦åŸå§‹ç‰ˆæœ¬ï¼ˆæœ‰çªè®Šï¼‰...', '#f00');
            const resultOld = testHeadingSmoothing(frenet, frenetToWorldOld, 1000);

            log(`  - åš´é‡è·³è®Š (>2Â°): ${resultOld.jumps.length}`, '#f00');
            log(`  - å°è®ŠåŒ– (0.5-2Â°): ${resultOld.smallChanges.length}`, '#ff0');
            log(`  - å¹³æ»‘åº¦æŒ‡æ¨™: ${resultOld.smoothness.toFixed(2)}`, '#f00');
            if (resultOld.jumps.length > 0) {
                const maxJump = Math.max(...resultOld.jumps.map(j => j.diffDeg));
                log(`  - æœ€å¤§è·³è®Š: ${maxJump.toFixed(2)}Â°`, '#f00');
            }
            log('');

            // æ¸¬è©¦ä¿®æ­£ç‰ˆæœ¬
            log('æ¸¬è©¦ä¿®æ­£ç‰ˆæœ¬ï¼ˆå¹³æ»‘ï¼‰...', '#0f0');
            const resultNew = testHeadingSmoothing(frenet, frenetToWorldNew, 1000);

            log(`  - åš´é‡è·³è®Š (>2Â°): ${resultNew.jumps.length}`, '#0f0');
            log(`  - å°è®ŠåŒ– (0.5-2Â°): ${resultNew.smallChanges.length}`, '#ff0');
            log(`  - å¹³æ»‘åº¦æŒ‡æ¨™: ${resultNew.smoothness.toFixed(2)}`, '#0f0');
            if (resultNew.jumps.length > 0) {
                const maxJump = Math.max(...resultNew.jumps.map(j => j.diffDeg));
                log(`  - æœ€å¤§è·³è®Š: ${maxJump.toFixed(2)}Â°`, '#0f0');
            }
            log('');

            // ç¹ªè£½çµæœ
            drawResults(
                document.getElementById('canvasBad'),
                resultOld.headings,
                resultOld.jumps,
                resultOld.smallChanges || []
            );
            drawResults(
                document.getElementById('canvasGood'),
                resultNew.headings,
                resultNew.jumps,
                resultNew.smallChanges || []
            );

            // æ›´æ–°çµ±è¨ˆ
            const maxJumpOld = resultOld.jumps.length > 0 ?
                Math.max(...resultOld.jumps.map(j => j.diffDeg)) : 0;
            const maxJumpNew = resultNew.jumps.length > 0 ?
                Math.max(...resultNew.jumps.map(j => j.diffDeg)) : 0;

            document.getElementById('statsBad').innerHTML = `
                <div class="jump">åš´é‡è·³è®Š (>2Â°): ${resultOld.jumps.length}</div>
                <div style="color: #ff0;">å°è®ŠåŒ–: ${resultOld.smallChanges?.length || 0}</div>
                <div class="jump">æœ€å¤§è·³è®Š: ${maxJumpOld.toFixed(2)}Â°</div>
                <div class="jump">å¹³æ»‘åº¦: ${resultOld.smoothness.toFixed(2)}</div>
                <div>é€™å°±æ˜¯é€ æˆå¡é “çš„åŸå› ï¼</div>
            `;

            document.getElementById('statsGood').innerHTML = `
                <div class="smooth">åš´é‡è·³è®Š (>2Â°): ${resultNew.jumps.length}</div>
                <div style="color: #ff0;">å°è®ŠåŒ–: ${resultNew.smallChanges?.length || 0}</div>
                <div class="smooth">æœ€å¤§è·³è®Š: ${maxJumpNew.toFixed(2)}Â°</div>
                <div class="smooth">å¹³æ»‘åº¦: ${resultNew.smoothness.toFixed(2)}</div>
                <div>å¤§å¹…æ”¹å–„ âœ“</div>
            `;

            log('=== æ¸¬è©¦å®Œæˆ ===', '#ff0');
            log('');

            const improvement = ((resultOld.smoothness - resultNew.smoothness) / resultOld.smoothness * 100);
            log(`å¹³æ»‘åº¦æ”¹å–„: ${improvement.toFixed(1)}%`, '#0f0');
            log(`åš´é‡è·³è®Šæ¸›å°‘: ${resultOld.jumps.length} â†’ ${resultNew.jumps.length}`, resultNew.jumps.length === 0 ? '#0f0' : '#ff0');
            log('');
            log('âœ… çµè«–: ä¿®æ­£ç‰ˆæœ¬å¤§å¹…é™ä½å¡é “ï¼', '#0f0');
        }

        log('æº–å‚™å°±ç·’ï¼Œé»æ“Šã€ŒåŸ·è¡Œæ¸¬è©¦ã€é–‹å§‹è¨ºæ–·');
    </script>
</body>

</html>